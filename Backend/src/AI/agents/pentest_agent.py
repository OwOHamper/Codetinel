from typing import Optional, Dict, Any
from langchain.tools import tool
from pydantic import BaseModel, Field
from src.AI.tools.web_tools import create_web_request, create_code_search
from .base_agent import BaseAgentManager
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

class PentestAgent(BaseAgentManager):
    """Specialized agent for testing specific vulnerabilities in web applications"""
    
    def __init__(
        self,
        openai_api_key: str,
        project_id: str,
        target_url: str,
        model_name: str = "gpt-4o",
        temperature: float = 0
    ):
        # Create system message using ChatPromptTemplate
        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a security expert specialized in testing specific vulnerabilities in web applications.
            Your goal is to:
            Follow these steps:
            1. Research the vulnerability and common exploitation methods
            2. Analyze the endpoint for potential vulnerability for multiple methods
            3. Design and execute appropriate security tests
            4. Return a JSON object: 
            ```{{
                "suggestion": write a suggestion on how to fix the vulnerability,
                "importance": write here importance on a scale of 1 to 10,
                "exploitable": write here if the vulnerability is exploitable with the provided tool or not in a boolean value,
            }}```"""),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad"),
        ])
        
        # Initialize tools with pre-configured code search
        tools = [
            create_code_search(project_id=project_id),  # Creates code search with project_id built in
            create_web_request(base_url=target_url),
        ]
        
        super().__init__(
            openai_api_key=openai_api_key,
            model_name=model_name,
            temperature=temperature,
            system_message=prompt,
            tools=tools
        )
        
        self.target_url = target_url

    async def test_vulnerability(
        self,
        vulnerability_type: str,
        endpoint: str,
        additional_context: str = None,
        file_context: str = None,
        line_number: int = None
    ) -> Dict[str, Any]:
        """Test a specific vulnerability on an endpoint"""
        message = {
            "input": f"""
            Test the following vulnerability:
            - Type: {vulnerability_type}
            - Endpoint: {endpoint}
            - Additional Context: {additional_context or ''}
            - Here is the context of where the vulnerability is located in file: {file_context or 'Not specified'}
            """
        }
        
        response = await self.process_message(message)
        output = response.get("output", "")
        
        # Extract JSON from the response
        try:
            # First try with ```
            json_parts = output.split("```json").replace("\n", '')
            
            if len(json_parts) > 1:
                json_content = json_parts[1].split("```")[0]
                json_previous_part = json_parts[0]
                json_last_part = json_parts[1].split("```")[1]
            else:
                
                # If ```json not found, try with just ```
                json_parts = output.split("```")
                
                if len(json_parts) > 1:
                    json_content = json_parts[1].split("```")[0]
                    json_previous_part = json_parts[0]
                    json_last_part = json_parts[1].split("```")[1]
                else:
                    return {
                        "suggestion": "No JSON content found in response",
                        "importance": 0,
                        "exploitable": False
                    },False
            if len(json_last_part) < 5:
                        json_last_part = ""
            # Parse the JSON string into a dictionary
            import json
            return_json = json.loads(json_content.strip())
            return_json.update({
                "previous_part": json_previous_part,
                "last_part": json_last_part,
                "file_context": file_context,
                "line_number": line_number,
                })
            return return_json
        except Exception as e:
            return{
                "suggestion": f"Error parsing response: {str(e)}",
                "importance": 0,
                "exploitable": False
            },False