from typing import Optional, Dict, Any
from langchain.tools import tool
from pydantic import BaseModel, Field
from src.AI.tools.web_tools import create_web_request, create_code_search
from .base_agent import BaseAgentManager
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

class PentestAgent(BaseAgentManager):
    """Specialized agent for testing specific vulnerabilities in web applications"""
    
    def __init__(
        self,
        openai_api_key: str,
        project_id: str,
        target_url: str,
        model_name: str = "gpt-4o",
        temperature: float = 0
    ):
        # Create system message using ChatPromptTemplate
        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are a security expert specialized in testing specific vulnerabilities in web applications.

Your task is to analyze and test web application endpoints for security vulnerabilities. Follow these steps precisely:

1. Analyze the endpoint for potential vulnerability for multiple methods and exploit techniques
2. Design and execute appropriate security tests using all tools available to you!
3. If you can assume from the request that the vunlerability is actually exploitable ONLY THEN ASSUME IT IS!
4. Return your findings in this EXACT format:
```json{{
    "suggestion": "<clear, actionable steps to fix the vulnerability>",
    "importance": <number between 1-10, where 1 is lowest and 10 is highest severity>,
    "exploitable": <must be exactly true if vulnerability was confirmed, false otherwise>
}}```

IMPORTANT RULES:
- The "exploitable" field must be exactly true or false (lowercase, boolean)
- The "importance" field must be an integer between 1 and 10
- Only mark "exploitable" as true if you could actually confirm the vulnerability exists
- If you cannot conclusively verify the vulnerability, "exploitable" must be false
"""),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad"),
        ])
        
        # Initialize tools with pre-configured code search
        tools = [
            create_code_search(project_id=project_id),  # Creates code search with project_id built in
            create_web_request(base_url=target_url),
        ]
        
        super().__init__(
            openai_api_key=openai_api_key,
            model_name=model_name,
            temperature=temperature,
            system_message=prompt,
            tools=tools
        )
        
        self.target_url = target_url

    async def test_vulnerability(
        self,
        vulnerability_type: str,
        endpoint: str,
        additional_context: str = None,
        file_context: str = None,
        line_number: int = None
    ) -> Dict[str, Any]:
        """Test a specific vulnerability on an endpoint"""
        message = {
            "input": f"""
            Test the following vulnerability:
            - Type: {vulnerability_type}
            - Endpoint: {endpoint}
            - Additional Context: {additional_context or ''}
            - Here is the context of where the vulnerability is located in file: {file_context or 'Not specified'}
            """
        }
        
        response = await self.process_message(message)
        output = response.get("output", "")
        
        # Extract JSON from the response
        try:
            # First try with ```
            json_parts = output.split("```json")
            
            if len(json_parts) > 1:
                json_content = json_parts[1].split("```")[0]
                json_previous_part = json_parts[0]
                json_last_part = json_parts[1].split("```")[1]
            else:
                
                # If ```json not found, try with just ```
                json_parts = output.split("```")
                
                if len(json_parts) > 1:
                    json_content = json_parts[1].split("```")[0]
                    json_previous_part = json_parts[0]
                    json_last_part = json_parts[1].split("```")[1]
                else:
                    return {
                        "suggestion": "No JSON content found in response",
                        "importance": 0,
                        "exploitable": False
                    },False
            if len(json_last_part) < 5:
                        json_last_part = ""
            # Parse the JSON string into a dictionary
            import json
            return_json = json.loads(json_content.strip())
            return_json.update({
                "previous_part": json_previous_part,
                "last_part": json_last_part,
                "file_context": file_context,
                "line_number": line_number,
                })
            return return_json
        except Exception as e:
            return{
                "suggestion": f"Error parsing response: {str(e)}",
                "importance": 0,
                "exploitable": False
            },False